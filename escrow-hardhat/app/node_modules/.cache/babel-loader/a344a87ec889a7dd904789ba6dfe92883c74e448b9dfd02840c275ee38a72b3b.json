{"ast":null,"code":"// nb. This is for IE10 and lower _only_.\nvar supportCustomEvent = window.CustomEvent;\nif (!supportCustomEvent || typeof supportCustomEvent === 'object') {\n  supportCustomEvent = function CustomEvent(event, x) {\n    x = x || {};\n    var ev = document.createEvent('CustomEvent');\n    ev.initCustomEvent(event, !!x.bubbles, !!x.cancelable, x.detail || null);\n    return ev;\n  };\n  supportCustomEvent.prototype = window.Event.prototype;\n}\n\n/**\n * Dispatches the passed event to both an \"on<type>\" handler as well as via the\n * normal dispatch operation. Does not bubble.\n *\n * @param {!EventTarget} target\n * @param {!Event} event\n * @return {boolean}\n */\nfunction safeDispatchEvent(target, event) {\n  var check = 'on' + event.type.toLowerCase();\n  if (typeof target[check] === 'function') {\n    target[check](event);\n  }\n  return target.dispatchEvent(event);\n}\n\n/**\n * @param {Element} el to check for stacking context\n * @return {boolean} whether this el or its parents creates a stacking context\n */\nfunction createsStackingContext(el) {\n  while (el && el !== document.body) {\n    var s = window.getComputedStyle(el);\n    var invalid = function (k, ok) {\n      return !(s[k] === undefined || s[k] === ok);\n    };\n    if (s.opacity < 1 || invalid('zIndex', 'auto') || invalid('transform', 'none') || invalid('mixBlendMode', 'normal') || invalid('filter', 'none') || invalid('perspective', 'none') || s['isolation'] === 'isolate' || s.position === 'fixed' || s.webkitOverflowScrolling === 'touch') {\n      return true;\n    }\n    el = el.parentElement;\n  }\n  return false;\n}\n\n/**\n * Finds the nearest <dialog> from the passed element.\n *\n * @param {Element} el to search from\n * @return {HTMLDialogElement} dialog found\n */\nfunction findNearestDialog(el) {\n  while (el) {\n    if (el.localName === 'dialog') {\n      return (/** @type {HTMLDialogElement} */el\n      );\n    }\n    if (el.parentElement) {\n      el = el.parentElement;\n    } else if (el.parentNode) {\n      el = el.parentNode.host;\n    } else {\n      el = null;\n    }\n  }\n  return null;\n}\n\n/**\n * Blur the specified element, as long as it's not the HTML body element.\n * This works around an IE9/10 bug - blurring the body causes Windows to\n * blur the whole application.\n *\n * @param {Element} el to blur\n */\nfunction safeBlur(el) {\n  // Find the actual focused element when the active element is inside a shadow root\n  while (el && el.shadowRoot && el.shadowRoot.activeElement) {\n    el = el.shadowRoot.activeElement;\n  }\n  if (el && el.blur && el !== document.body) {\n    el.blur();\n  }\n}\n\n/**\n * @param {!NodeList} nodeList to search\n * @param {Node} node to find\n * @return {boolean} whether node is inside nodeList\n */\nfunction inNodeList(nodeList, node) {\n  for (var i = 0; i < nodeList.length; ++i) {\n    if (nodeList[i] === node) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * @param {HTMLFormElement} el to check\n * @return {boolean} whether this form has method=\"dialog\"\n */\nfunction isFormMethodDialog(el) {\n  if (!el || !el.hasAttribute('method')) {\n    return false;\n  }\n  return el.getAttribute('method').toLowerCase() === 'dialog';\n}\n\n/**\n * @param {!DocumentFragment|!Element} hostElement\n * @return {?Element}\n */\nfunction findFocusableElementWithin(hostElement) {\n  // Note that this is 'any focusable area'. This list is probably not exhaustive, but the\n  // alternative involves stepping through and trying to focus everything.\n  var opts = ['button', 'input', 'keygen', 'select', 'textarea'];\n  var query = opts.map(function (el) {\n    return el + ':not([disabled])';\n  });\n  // TODO(samthor): tabindex values that are not numeric are not focusable.\n  query.push('[tabindex]:not([disabled]):not([tabindex=\"\"])'); // tabindex != \"\", not disabled\n  var target = hostElement.querySelector(query.join(', '));\n  if (!target && 'attachShadow' in Element.prototype) {\n    // If we haven't found a focusable target, see if the host element contains an element\n    // which has a shadowRoot.\n    // Recursively search for the first focusable item in shadow roots.\n    var elems = hostElement.querySelectorAll('*');\n    for (var i = 0; i < elems.length; i++) {\n      if (elems[i].tagName && elems[i].shadowRoot) {\n        target = findFocusableElementWithin(elems[i].shadowRoot);\n        if (target) {\n          break;\n        }\n      }\n    }\n  }\n  return target;\n}\n\n/**\n * Determines if an element is attached to the DOM.\n * @param {Element} element to check\n * @return {boolean} whether the element is in DOM\n */\nfunction isConnected(element) {\n  return element.isConnected || document.body.contains(element);\n}\n\n/**\n * @param {!Event} event\n * @return {?Element}\n */\nfunction findFormSubmitter(event) {\n  if (event.submitter) {\n    return event.submitter;\n  }\n  var form = event.target;\n  if (!(form instanceof HTMLFormElement)) {\n    return null;\n  }\n  var submitter = dialogPolyfill.formSubmitter;\n  if (!submitter) {\n    var target = event.target;\n    var root = 'getRootNode' in target && target.getRootNode() || document;\n    submitter = root.activeElement;\n  }\n  if (!submitter || submitter.form !== form) {\n    return null;\n  }\n  return submitter;\n}\n\n/**\n * @param {!Event} event\n */\nfunction maybeHandleSubmit(event) {\n  if (event.defaultPrevented) {\n    return;\n  }\n  var form = /** @type {!HTMLFormElement} */event.target;\n\n  // We'd have a value if we clicked on an imagemap.\n  var value = dialogPolyfill.imagemapUseValue;\n  var submitter = findFormSubmitter(event);\n  if (value === null && submitter) {\n    value = submitter.value;\n  }\n\n  // There should always be a dialog as this handler is added specifically on them, but check just\n  // in case.\n  var dialog = findNearestDialog(form);\n  if (!dialog) {\n    return;\n  }\n\n  // Prefer formmethod on the button.\n  var formmethod = submitter && submitter.getAttribute('formmethod') || form.getAttribute('method');\n  if (formmethod !== 'dialog') {\n    return;\n  }\n  event.preventDefault();\n  if (value != null) {\n    // nb. we explicitly check against null/undefined\n    dialog.close(value);\n  } else {\n    dialog.close();\n  }\n}\n\n/**\n * @param {!HTMLDialogElement} dialog to upgrade\n * @constructor\n */\nfunction dialogPolyfillInfo(dialog) {\n  this.dialog_ = dialog;\n  this.replacedStyleTop_ = false;\n  this.openAsModal_ = false;\n\n  // Set a11y role. Browsers that support dialog implicitly know this already.\n  if (!dialog.hasAttribute('role')) {\n    dialog.setAttribute('role', 'dialog');\n  }\n  dialog.show = this.show.bind(this);\n  dialog.showModal = this.showModal.bind(this);\n  dialog.close = this.close.bind(this);\n  dialog.addEventListener('submit', maybeHandleSubmit, false);\n  if (!('returnValue' in dialog)) {\n    dialog.returnValue = '';\n  }\n  if ('MutationObserver' in window) {\n    var mo = new MutationObserver(this.maybeHideModal.bind(this));\n    mo.observe(dialog, {\n      attributes: true,\n      attributeFilter: ['open']\n    });\n  } else {\n    // IE10 and below support. Note that DOMNodeRemoved etc fire _before_ removal. They also\n    // seem to fire even if the element was removed as part of a parent removal. Use the removed\n    // events to force downgrade (useful if removed/immediately added).\n    var removed = false;\n    var cb = function () {\n      removed ? this.downgradeModal() : this.maybeHideModal();\n      removed = false;\n    }.bind(this);\n    var timeout;\n    var delayModel = function (ev) {\n      if (ev.target !== dialog) {\n        return;\n      } // not for a child element\n      var cand = 'DOMNodeRemoved';\n      removed |= ev.type.substr(0, cand.length) === cand;\n      window.clearTimeout(timeout);\n      timeout = window.setTimeout(cb, 0);\n    };\n    ['DOMAttrModified', 'DOMNodeRemoved', 'DOMNodeRemovedFromDocument'].forEach(function (name) {\n      dialog.addEventListener(name, delayModel);\n    });\n  }\n  // Note that the DOM is observed inside DialogManager while any dialog\n  // is being displayed as a modal, to catch modal removal from the DOM.\n\n  Object.defineProperty(dialog, 'open', {\n    set: this.setOpen.bind(this),\n    get: dialog.hasAttribute.bind(dialog, 'open')\n  });\n  this.backdrop_ = document.createElement('div');\n  this.backdrop_.className = 'backdrop';\n  this.backdrop_.addEventListener('mouseup', this.backdropMouseEvent_.bind(this));\n  this.backdrop_.addEventListener('mousedown', this.backdropMouseEvent_.bind(this));\n  this.backdrop_.addEventListener('click', this.backdropMouseEvent_.bind(this));\n}\ndialogPolyfillInfo.prototype = /** @type {HTMLDialogElement.prototype} */{\n  get dialog() {\n    return this.dialog_;\n  },\n  /**\n   * Maybe remove this dialog from the modal top layer. This is called when\n   * a modal dialog may no longer be tenable, e.g., when the dialog is no\n   * longer open or is no longer part of the DOM.\n   */\n  maybeHideModal: function () {\n    if (this.dialog_.hasAttribute('open') && isConnected(this.dialog_)) {\n      return;\n    }\n    this.downgradeModal();\n  },\n  /**\n   * Remove this dialog from the modal top layer, leaving it as a non-modal.\n   */\n  downgradeModal: function () {\n    if (!this.openAsModal_) {\n      return;\n    }\n    this.openAsModal_ = false;\n    this.dialog_.style.zIndex = '';\n\n    // This won't match the native <dialog> exactly because if the user set top on a centered\n    // polyfill dialog, that top gets thrown away when the dialog is closed. Not sure it's\n    // possible to polyfill this perfectly.\n    if (this.replacedStyleTop_) {\n      this.dialog_.style.top = '';\n      this.replacedStyleTop_ = false;\n    }\n\n    // Clear the backdrop and remove from the manager.\n    this.backdrop_.parentNode && this.backdrop_.parentNode.removeChild(this.backdrop_);\n    dialogPolyfill.dm.removeDialog(this);\n  },\n  /**\n   * @param {boolean} value whether to open or close this dialog\n   */\n  setOpen: function (value) {\n    if (value) {\n      this.dialog_.hasAttribute('open') || this.dialog_.setAttribute('open', '');\n    } else {\n      this.dialog_.removeAttribute('open');\n      this.maybeHideModal(); // nb. redundant with MutationObserver\n    }\n  },\n\n  /**\n   * Handles mouse events ('mouseup', 'mousedown', 'click') on the fake .backdrop element, redirecting them as if\n   * they were on the dialog itself.\n   *\n   * @param {!Event} e to redirect\n   */\n  backdropMouseEvent_: function (e) {\n    if (!this.dialog_.hasAttribute('tabindex')) {\n      // Clicking on the backdrop should move the implicit cursor, even if dialog cannot be\n      // focused. Create a fake thing to focus on. If the backdrop was _before_ the dialog, this\n      // would not be needed - clicks would move the implicit cursor there.\n      var fake = document.createElement('div');\n      this.dialog_.insertBefore(fake, this.dialog_.firstChild);\n      fake.tabIndex = -1;\n      fake.focus();\n      this.dialog_.removeChild(fake);\n    } else {\n      this.dialog_.focus();\n    }\n    var redirectedEvent = document.createEvent('MouseEvents');\n    redirectedEvent.initMouseEvent(e.type, e.bubbles, e.cancelable, window, e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget);\n    this.dialog_.dispatchEvent(redirectedEvent);\n    e.stopPropagation();\n  },\n  /**\n   * Focuses on the first focusable element within the dialog. This will always blur the current\n   * focus, even if nothing within the dialog is found.\n   */\n  focus_: function () {\n    // Find element with `autofocus` attribute, or fall back to the first form/tabindex control.\n    var target = this.dialog_.querySelector('[autofocus]:not([disabled])');\n    if (!target && this.dialog_.tabIndex >= 0) {\n      target = this.dialog_;\n    }\n    if (!target) {\n      target = findFocusableElementWithin(this.dialog_);\n    }\n    safeBlur(document.activeElement);\n    target && target.focus();\n  },\n  /**\n   * Sets the zIndex for the backdrop and dialog.\n   *\n   * @param {number} dialogZ\n   * @param {number} backdropZ\n   */\n  updateZIndex: function (dialogZ, backdropZ) {\n    if (dialogZ < backdropZ) {\n      throw new Error('dialogZ should never be < backdropZ');\n    }\n    this.dialog_.style.zIndex = dialogZ;\n    this.backdrop_.style.zIndex = backdropZ;\n  },\n  /**\n   * Shows the dialog. If the dialog is already open, this does nothing.\n   */\n  show: function () {\n    if (!this.dialog_.open) {\n      this.setOpen(true);\n      this.focus_();\n    }\n  },\n  /**\n   * Show this dialog modally.\n   */\n  showModal: function () {\n    if (this.dialog_.hasAttribute('open')) {\n      throw new Error('Failed to execute \\'showModal\\' on dialog: The element is already open, and therefore cannot be opened modally.');\n    }\n    if (!isConnected(this.dialog_)) {\n      throw new Error('Failed to execute \\'showModal\\' on dialog: The element is not in a Document.');\n    }\n    if (!dialogPolyfill.dm.pushDialog(this)) {\n      throw new Error('Failed to execute \\'showModal\\' on dialog: There are too many open modal dialogs.');\n    }\n    if (createsStackingContext(this.dialog_.parentElement)) {\n      console.warn('A dialog is being shown inside a stacking context. ' + 'This may cause it to be unusable. For more information, see this link: ' + 'https://github.com/GoogleChrome/dialog-polyfill/#stacking-context');\n    }\n    this.setOpen(true);\n    this.openAsModal_ = true;\n\n    // Optionally center vertically, relative to the current viewport.\n    if (dialogPolyfill.needsCentering(this.dialog_)) {\n      dialogPolyfill.reposition(this.dialog_);\n      this.replacedStyleTop_ = true;\n    } else {\n      this.replacedStyleTop_ = false;\n    }\n\n    // Insert backdrop.\n    this.dialog_.parentNode.insertBefore(this.backdrop_, this.dialog_.nextSibling);\n\n    // Focus on whatever inside the dialog.\n    this.focus_();\n  },\n  /**\n   * Closes this HTMLDialogElement. This is optional vs clearing the open\n   * attribute, however this fires a 'close' event.\n   *\n   * @param {string=} opt_returnValue to use as the returnValue\n   */\n  close: function (opt_returnValue) {\n    if (!this.dialog_.hasAttribute('open')) {\n      throw new Error('Failed to execute \\'close\\' on dialog: The element does not have an \\'open\\' attribute, and therefore cannot be closed.');\n    }\n    this.setOpen(false);\n\n    // Leave returnValue untouched in case it was set directly on the element\n    if (opt_returnValue !== undefined) {\n      this.dialog_.returnValue = opt_returnValue;\n    }\n\n    // Triggering \"close\" event for any attached listeners on the <dialog>.\n    var closeEvent = new supportCustomEvent('close', {\n      bubbles: false,\n      cancelable: false\n    });\n    safeDispatchEvent(this.dialog_, closeEvent);\n  }\n};\nvar dialogPolyfill = {};\ndialogPolyfill.reposition = function (element) {\n  var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  var topValue = scrollTop + (window.innerHeight - element.offsetHeight) / 2;\n  element.style.top = Math.max(scrollTop, topValue) + 'px';\n};\ndialogPolyfill.isInlinePositionSetByStylesheet = function (element) {\n  for (var i = 0; i < document.styleSheets.length; ++i) {\n    var styleSheet = document.styleSheets[i];\n    var cssRules = null;\n    // Some browsers throw on cssRules.\n    try {\n      cssRules = styleSheet.cssRules;\n    } catch (e) {}\n    if (!cssRules) {\n      continue;\n    }\n    for (var j = 0; j < cssRules.length; ++j) {\n      var rule = cssRules[j];\n      var selectedNodes = null;\n      // Ignore errors on invalid selector texts.\n      try {\n        selectedNodes = document.querySelectorAll(rule.selectorText);\n      } catch (e) {}\n      if (!selectedNodes || !inNodeList(selectedNodes, element)) {\n        continue;\n      }\n      var cssTop = rule.style.getPropertyValue('top');\n      var cssBottom = rule.style.getPropertyValue('bottom');\n      if (cssTop && cssTop !== 'auto' || cssBottom && cssBottom !== 'auto') {\n        return true;\n      }\n    }\n  }\n  return false;\n};\ndialogPolyfill.needsCentering = function (dialog) {\n  var computedStyle = window.getComputedStyle(dialog);\n  if (computedStyle.position !== 'absolute') {\n    return false;\n  }\n\n  // We must determine whether the top/bottom specified value is non-auto.  In\n  // WebKit/Blink, checking computedStyle.top == 'auto' is sufficient, but\n  // Firefox returns the used value. So we do this crazy thing instead: check\n  // the inline style and then go through CSS rules.\n  if (dialog.style.top !== 'auto' && dialog.style.top !== '' || dialog.style.bottom !== 'auto' && dialog.style.bottom !== '') {\n    return false;\n  }\n  return !dialogPolyfill.isInlinePositionSetByStylesheet(dialog);\n};\n\n/**\n * @param {!Element} element to force upgrade\n */\ndialogPolyfill.forceRegisterDialog = function (element) {\n  if (window.HTMLDialogElement || element.showModal) {\n    console.warn('This browser already supports <dialog>, the polyfill ' + 'may not work correctly', element);\n  }\n  if (element.localName !== 'dialog') {\n    throw new Error('Failed to register dialog: The element is not a dialog.');\n  }\n  new dialogPolyfillInfo( /** @type {!HTMLDialogElement} */element);\n};\n\n/**\n * @param {!Element} element to upgrade, if necessary\n */\ndialogPolyfill.registerDialog = function (element) {\n  if (!element.showModal) {\n    dialogPolyfill.forceRegisterDialog(element);\n  }\n};\n\n/**\n * @constructor\n */\ndialogPolyfill.DialogManager = function () {\n  /** @type {!Array<!dialogPolyfillInfo>} */\n  this.pendingDialogStack = [];\n  var checkDOM = this.checkDOM_.bind(this);\n\n  // The overlay is used to simulate how a modal dialog blocks the document.\n  // The blocking dialog is positioned on top of the overlay, and the rest of\n  // the dialogs on the pending dialog stack are positioned below it. In the\n  // actual implementation, the modal dialog stacking is controlled by the\n  // top layer, where z-index has no effect.\n  this.overlay = document.createElement('div');\n  this.overlay.className = '_dialog_overlay';\n  this.overlay.addEventListener('click', function (e) {\n    this.forwardTab_ = undefined;\n    e.stopPropagation();\n    checkDOM([]); // sanity-check DOM\n  }.bind(this));\n  this.handleKey_ = this.handleKey_.bind(this);\n  this.handleFocus_ = this.handleFocus_.bind(this);\n  this.zIndexLow_ = 100000;\n  this.zIndexHigh_ = 100000 + 150;\n  this.forwardTab_ = undefined;\n  if ('MutationObserver' in window) {\n    this.mo_ = new MutationObserver(function (records) {\n      var removed = [];\n      records.forEach(function (rec) {\n        for (var i = 0, c; c = rec.removedNodes[i]; ++i) {\n          if (!(c instanceof Element)) {\n            continue;\n          } else if (c.localName === 'dialog') {\n            removed.push(c);\n          }\n          removed = removed.concat(c.querySelectorAll('dialog'));\n        }\n      });\n      removed.length && checkDOM(removed);\n    });\n  }\n};\n\n/**\n * Called on the first modal dialog being shown. Adds the overlay and related\n * handlers.\n */\ndialogPolyfill.DialogManager.prototype.blockDocument = function () {\n  document.documentElement.addEventListener('focus', this.handleFocus_, true);\n  document.addEventListener('keydown', this.handleKey_);\n  this.mo_ && this.mo_.observe(document, {\n    childList: true,\n    subtree: true\n  });\n};\n\n/**\n * Called on the first modal dialog being removed, i.e., when no more modal\n * dialogs are visible.\n */\ndialogPolyfill.DialogManager.prototype.unblockDocument = function () {\n  document.documentElement.removeEventListener('focus', this.handleFocus_, true);\n  document.removeEventListener('keydown', this.handleKey_);\n  this.mo_ && this.mo_.disconnect();\n};\n\n/**\n * Updates the stacking of all known dialogs.\n */\ndialogPolyfill.DialogManager.prototype.updateStacking = function () {\n  var zIndex = this.zIndexHigh_;\n  for (var i = 0, dpi; dpi = this.pendingDialogStack[i]; ++i) {\n    dpi.updateZIndex(--zIndex, --zIndex);\n    if (i === 0) {\n      this.overlay.style.zIndex = --zIndex;\n    }\n  }\n\n  // Make the overlay a sibling of the dialog itself.\n  var last = this.pendingDialogStack[0];\n  if (last) {\n    var p = last.dialog.parentNode || document.body;\n    p.appendChild(this.overlay);\n  } else if (this.overlay.parentNode) {\n    this.overlay.parentNode.removeChild(this.overlay);\n  }\n};\n\n/**\n * @param {Element} candidate to check if contained or is the top-most modal dialog\n * @return {boolean} whether candidate is contained in top dialog\n */\ndialogPolyfill.DialogManager.prototype.containedByTopDialog_ = function (candidate) {\n  while (candidate = findNearestDialog(candidate)) {\n    for (var i = 0, dpi; dpi = this.pendingDialogStack[i]; ++i) {\n      if (dpi.dialog === candidate) {\n        return i === 0; // only valid if top-most\n      }\n    }\n\n    candidate = candidate.parentElement;\n  }\n  return false;\n};\ndialogPolyfill.DialogManager.prototype.handleFocus_ = function (event) {\n  var target = event.composedPath ? event.composedPath()[0] : event.target;\n  if (this.containedByTopDialog_(target)) {\n    return;\n  }\n  if (document.activeElement === document.documentElement) {\n    return;\n  }\n  event.preventDefault();\n  event.stopPropagation();\n  safeBlur( /** @type {Element} */target);\n  if (this.forwardTab_ === undefined) {\n    return;\n  } // move focus only from a tab key\n\n  var dpi = this.pendingDialogStack[0];\n  var dialog = dpi.dialog;\n  var position = dialog.compareDocumentPosition(target);\n  if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n    if (this.forwardTab_) {\n      // forward\n      dpi.focus_();\n    } else if (target !== document.documentElement) {\n      // backwards if we're not already focused on <html>\n      document.documentElement.focus();\n    }\n  }\n  return false;\n};\ndialogPolyfill.DialogManager.prototype.handleKey_ = function (event) {\n  this.forwardTab_ = undefined;\n  if (event.keyCode === 27) {\n    event.preventDefault();\n    event.stopPropagation();\n    var cancelEvent = new supportCustomEvent('cancel', {\n      bubbles: false,\n      cancelable: true\n    });\n    var dpi = this.pendingDialogStack[0];\n    if (dpi && safeDispatchEvent(dpi.dialog, cancelEvent)) {\n      dpi.dialog.close();\n    }\n  } else if (event.keyCode === 9) {\n    this.forwardTab_ = !event.shiftKey;\n  }\n};\n\n/**\n * Finds and downgrades any known modal dialogs that are no longer displayed. Dialogs that are\n * removed and immediately readded don't stay modal, they become normal.\n *\n * @param {!Array<!HTMLDialogElement>} removed that have definitely been removed\n */\ndialogPolyfill.DialogManager.prototype.checkDOM_ = function (removed) {\n  // This operates on a clone because it may cause it to change. Each change also calls\n  // updateStacking, which only actually needs to happen once. But who removes many modal dialogs\n  // at a time?!\n  var clone = this.pendingDialogStack.slice();\n  clone.forEach(function (dpi) {\n    if (removed.indexOf(dpi.dialog) !== -1) {\n      dpi.downgradeModal();\n    } else {\n      dpi.maybeHideModal();\n    }\n  });\n};\n\n/**\n * @param {!dialogPolyfillInfo} dpi\n * @return {boolean} whether the dialog was allowed\n */\ndialogPolyfill.DialogManager.prototype.pushDialog = function (dpi) {\n  var allowed = (this.zIndexHigh_ - this.zIndexLow_) / 2 - 1;\n  if (this.pendingDialogStack.length >= allowed) {\n    return false;\n  }\n  if (this.pendingDialogStack.unshift(dpi) === 1) {\n    this.blockDocument();\n  }\n  this.updateStacking();\n  return true;\n};\n\n/**\n * @param {!dialogPolyfillInfo} dpi\n */\ndialogPolyfill.DialogManager.prototype.removeDialog = function (dpi) {\n  var index = this.pendingDialogStack.indexOf(dpi);\n  if (index === -1) {\n    return;\n  }\n  this.pendingDialogStack.splice(index, 1);\n  if (this.pendingDialogStack.length === 0) {\n    this.unblockDocument();\n  }\n  this.updateStacking();\n};\ndialogPolyfill.dm = new dialogPolyfill.DialogManager();\ndialogPolyfill.formSubmitter = null;\ndialogPolyfill.imagemapUseValue = null;\n\n/**\n * Installs global handlers, such as click listers and native method overrides. These are needed\n * even if a no dialog is registered, as they deal with <form method=\"dialog\">.\n */\nif (window.HTMLDialogElement === undefined) {\n  /**\n   * If HTMLFormElement translates method=\"DIALOG\" into 'get', then replace the descriptor with\n   * one that returns the correct value.\n   */\n  var testForm = document.createElement('form');\n  testForm.setAttribute('method', 'dialog');\n  if (testForm.method !== 'dialog') {\n    var methodDescriptor = Object.getOwnPropertyDescriptor(HTMLFormElement.prototype, 'method');\n    if (methodDescriptor) {\n      // nb. Some older iOS and older PhantomJS fail to return the descriptor. Don't do anything\n      // and don't bother to update the element.\n      var realGet = methodDescriptor.get;\n      methodDescriptor.get = function () {\n        if (isFormMethodDialog(this)) {\n          return 'dialog';\n        }\n        return realGet.call(this);\n      };\n      var realSet = methodDescriptor.set;\n      /** @this {HTMLElement} */\n      methodDescriptor.set = function (v) {\n        if (typeof v === 'string' && v.toLowerCase() === 'dialog') {\n          return this.setAttribute('method', v);\n        }\n        return realSet.call(this, v);\n      };\n      Object.defineProperty(HTMLFormElement.prototype, 'method', methodDescriptor);\n    }\n  }\n\n  /**\n   * Global 'click' handler, to capture the <input type=\"submit\"> or <button> element which has\n   * submitted a <form method=\"dialog\">. Needed as Safari and others don't report this inside\n   * document.activeElement.\n   */\n  document.addEventListener('click', function (ev) {\n    dialogPolyfill.formSubmitter = null;\n    dialogPolyfill.imagemapUseValue = null;\n    if (ev.defaultPrevented) {\n      return;\n    } // e.g. a submit which prevents default submission\n\n    var target = /** @type {Element} */ev.target;\n    if ('composedPath' in ev) {\n      var path = ev.composedPath();\n      target = path.shift() || target;\n    }\n    if (!target || !isFormMethodDialog(target.form)) {\n      return;\n    }\n    var valid = target.type === 'submit' && ['button', 'input'].indexOf(target.localName) > -1;\n    if (!valid) {\n      if (!(target.localName === 'input' && target.type === 'image')) {\n        return;\n      }\n      // this is a <input type=\"image\">, which can submit forms\n      dialogPolyfill.imagemapUseValue = ev.offsetX + ',' + ev.offsetY;\n    }\n    var dialog = findNearestDialog(target);\n    if (!dialog) {\n      return;\n    }\n    dialogPolyfill.formSubmitter = target;\n  }, false);\n\n  /**\n   * Global 'submit' handler. This handles submits of `method=\"dialog\"` which are invalid, i.e.,\n   * outside a dialog. They get prevented.\n   */\n  document.addEventListener('submit', function (ev) {\n    var form = ev.target;\n    var dialog = findNearestDialog(form);\n    if (dialog) {\n      return; // ignore, handle there\n    }\n\n    var submitter = findFormSubmitter(ev);\n    var formmethod = submitter && submitter.getAttribute('formmethod') || form.getAttribute('method');\n    if (formmethod === 'dialog') {\n      ev.preventDefault();\n    }\n  });\n\n  /**\n   * Replace the native HTMLFormElement.submit() method, as it won't fire the\n   * submit event and give us a chance to respond.\n   */\n  var nativeFormSubmit = HTMLFormElement.prototype.submit;\n  var replacementFormSubmit = function () {\n    if (!isFormMethodDialog(this)) {\n      return nativeFormSubmit.call(this);\n    }\n    var dialog = findNearestDialog(this);\n    dialog && dialog.close();\n  };\n  HTMLFormElement.prototype.submit = replacementFormSubmit;\n}\nexport default dialogPolyfill;","map":{"version":3,"names":["supportCustomEvent","window","CustomEvent","event","x","ev","document","createEvent","initCustomEvent","bubbles","cancelable","detail","prototype","Event","safeDispatchEvent","target","check","type","toLowerCase","dispatchEvent","createsStackingContext","el","body","s","getComputedStyle","invalid","k","ok","undefined","opacity","position","webkitOverflowScrolling","parentElement","findNearestDialog","localName","parentNode","host","safeBlur","shadowRoot","activeElement","blur","inNodeList","nodeList","node","i","length","isFormMethodDialog","hasAttribute","getAttribute","findFocusableElementWithin","hostElement","opts","query","map","push","querySelector","join","Element","elems","querySelectorAll","tagName","isConnected","element","contains","findFormSubmitter","submitter","form","HTMLFormElement","dialogPolyfill","formSubmitter","root","getRootNode","maybeHandleSubmit","defaultPrevented","value","imagemapUseValue","dialog","formmethod","preventDefault","close","dialogPolyfillInfo","dialog_","replacedStyleTop_","openAsModal_","setAttribute","show","bind","showModal","addEventListener","returnValue","mo","MutationObserver","maybeHideModal","observe","attributes","attributeFilter","removed","cb","downgradeModal","timeout","delayModel","cand","substr","clearTimeout","setTimeout","forEach","name","Object","defineProperty","set","setOpen","get","backdrop_","createElement","className","backdropMouseEvent_","style","zIndex","top","removeChild","dm","removeDialog","removeAttribute","e","fake","insertBefore","firstChild","tabIndex","focus","redirectedEvent","initMouseEvent","screenX","screenY","clientX","clientY","ctrlKey","altKey","shiftKey","metaKey","button","relatedTarget","stopPropagation","focus_","updateZIndex","dialogZ","backdropZ","Error","open","pushDialog","console","warn","needsCentering","reposition","nextSibling","opt_returnValue","closeEvent","scrollTop","documentElement","topValue","innerHeight","offsetHeight","Math","max","isInlinePositionSetByStylesheet","styleSheets","styleSheet","cssRules","j","rule","selectedNodes","selectorText","cssTop","getPropertyValue","cssBottom","computedStyle","bottom","forceRegisterDialog","HTMLDialogElement","registerDialog","DialogManager","pendingDialogStack","checkDOM","checkDOM_","overlay","forwardTab_","handleKey_","handleFocus_","zIndexLow_","zIndexHigh_","mo_","records","rec","c","removedNodes","concat","blockDocument","childList","subtree","unblockDocument","removeEventListener","disconnect","updateStacking","dpi","last","p","appendChild","containedByTopDialog_","candidate","composedPath","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","keyCode","cancelEvent","clone","slice","indexOf","allowed","unshift","index","splice","testForm","method","methodDescriptor","getOwnPropertyDescriptor","realGet","call","realSet","v","path","shift","valid","offsetX","offsetY","nativeFormSubmit","submit","replacementFormSubmit"],"sources":["D:/Escrow App/escrow-hardhat/app/node_modules/dialog-polyfill/dist/dialog-polyfill.esm.js"],"sourcesContent":["// nb. This is for IE10 and lower _only_.\nvar supportCustomEvent = window.CustomEvent;\nif (!supportCustomEvent || typeof supportCustomEvent === 'object') {\n  supportCustomEvent = function CustomEvent(event, x) {\n    x = x || {};\n    var ev = document.createEvent('CustomEvent');\n    ev.initCustomEvent(event, !!x.bubbles, !!x.cancelable, x.detail || null);\n    return ev;\n  };\n  supportCustomEvent.prototype = window.Event.prototype;\n}\n\n/**\n * Dispatches the passed event to both an \"on<type>\" handler as well as via the\n * normal dispatch operation. Does not bubble.\n *\n * @param {!EventTarget} target\n * @param {!Event} event\n * @return {boolean}\n */\nfunction safeDispatchEvent(target, event) {\n  var check = 'on' + event.type.toLowerCase();\n  if (typeof target[check] === 'function') {\n    target[check](event);\n  }\n  return target.dispatchEvent(event);\n}\n\n/**\n * @param {Element} el to check for stacking context\n * @return {boolean} whether this el or its parents creates a stacking context\n */\nfunction createsStackingContext(el) {\n  while (el && el !== document.body) {\n    var s = window.getComputedStyle(el);\n    var invalid = function(k, ok) {\n      return !(s[k] === undefined || s[k] === ok);\n    };\n\n    if (s.opacity < 1 ||\n        invalid('zIndex', 'auto') ||\n        invalid('transform', 'none') ||\n        invalid('mixBlendMode', 'normal') ||\n        invalid('filter', 'none') ||\n        invalid('perspective', 'none') ||\n        s['isolation'] === 'isolate' ||\n        s.position === 'fixed' ||\n        s.webkitOverflowScrolling === 'touch') {\n      return true;\n    }\n    el = el.parentElement;\n  }\n  return false;\n}\n\n/**\n * Finds the nearest <dialog> from the passed element.\n *\n * @param {Element} el to search from\n * @return {HTMLDialogElement} dialog found\n */\nfunction findNearestDialog(el) {\n  while (el) {\n    if (el.localName === 'dialog') {\n      return /** @type {HTMLDialogElement} */ (el);\n    }\n    if (el.parentElement) {\n      el = el.parentElement;\n    } else if (el.parentNode) {\n      el = el.parentNode.host;\n    } else {\n      el = null;\n    }\n  }\n  return null;\n}\n\n/**\n * Blur the specified element, as long as it's not the HTML body element.\n * This works around an IE9/10 bug - blurring the body causes Windows to\n * blur the whole application.\n *\n * @param {Element} el to blur\n */\nfunction safeBlur(el) {\n  // Find the actual focused element when the active element is inside a shadow root\n  while (el && el.shadowRoot && el.shadowRoot.activeElement) {\n    el = el.shadowRoot.activeElement;\n  }\n\n  if (el && el.blur && el !== document.body) {\n    el.blur();\n  }\n}\n\n/**\n * @param {!NodeList} nodeList to search\n * @param {Node} node to find\n * @return {boolean} whether node is inside nodeList\n */\nfunction inNodeList(nodeList, node) {\n  for (var i = 0; i < nodeList.length; ++i) {\n    if (nodeList[i] === node) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * @param {HTMLFormElement} el to check\n * @return {boolean} whether this form has method=\"dialog\"\n */\nfunction isFormMethodDialog(el) {\n  if (!el || !el.hasAttribute('method')) {\n    return false;\n  }\n  return el.getAttribute('method').toLowerCase() === 'dialog';\n}\n\n/**\n * @param {!DocumentFragment|!Element} hostElement\n * @return {?Element}\n */\nfunction findFocusableElementWithin(hostElement) {\n  // Note that this is 'any focusable area'. This list is probably not exhaustive, but the\n  // alternative involves stepping through and trying to focus everything.\n  var opts = ['button', 'input', 'keygen', 'select', 'textarea'];\n  var query = opts.map(function(el) {\n    return el + ':not([disabled])';\n  });\n  // TODO(samthor): tabindex values that are not numeric are not focusable.\n  query.push('[tabindex]:not([disabled]):not([tabindex=\"\"])');  // tabindex != \"\", not disabled\n  var target = hostElement.querySelector(query.join(', '));\n\n  if (!target && 'attachShadow' in Element.prototype) {\n    // If we haven't found a focusable target, see if the host element contains an element\n    // which has a shadowRoot.\n    // Recursively search for the first focusable item in shadow roots.\n    var elems = hostElement.querySelectorAll('*');\n    for (var i = 0; i < elems.length; i++) {\n      if (elems[i].tagName && elems[i].shadowRoot) {\n        target = findFocusableElementWithin(elems[i].shadowRoot);\n        if (target) {\n          break;\n        }\n      }\n    }\n  }\n  return target;\n}\n\n/**\n * Determines if an element is attached to the DOM.\n * @param {Element} element to check\n * @return {boolean} whether the element is in DOM\n */\nfunction isConnected(element) {\n  return element.isConnected || document.body.contains(element);\n}\n\n/**\n * @param {!Event} event\n * @return {?Element}\n */\nfunction findFormSubmitter(event) {\n  if (event.submitter) {\n    return event.submitter;\n  }\n\n  var form = event.target;\n  if (!(form instanceof HTMLFormElement)) {\n    return null;\n  }\n\n  var submitter = dialogPolyfill.formSubmitter;\n  if (!submitter) {\n    var target = event.target;\n    var root = ('getRootNode' in target && target.getRootNode() || document);\n    submitter = root.activeElement;\n  }\n\n  if (!submitter || submitter.form !== form) {\n    return null;\n  }\n  return submitter;\n}\n\n/**\n * @param {!Event} event\n */\nfunction maybeHandleSubmit(event) {\n  if (event.defaultPrevented) {\n    return;\n  }\n  var form = /** @type {!HTMLFormElement} */ (event.target);\n\n  // We'd have a value if we clicked on an imagemap.\n  var value = dialogPolyfill.imagemapUseValue;\n  var submitter = findFormSubmitter(event);\n  if (value === null && submitter) {\n    value = submitter.value;\n  }\n\n  // There should always be a dialog as this handler is added specifically on them, but check just\n  // in case.\n  var dialog = findNearestDialog(form);\n  if (!dialog) {\n    return;\n  }\n\n  // Prefer formmethod on the button.\n  var formmethod = submitter && submitter.getAttribute('formmethod') || form.getAttribute('method');\n  if (formmethod !== 'dialog') {\n    return;\n  }\n  event.preventDefault();\n\n  if (value != null) {\n    // nb. we explicitly check against null/undefined\n    dialog.close(value);\n  } else {\n    dialog.close();\n  }\n}\n\n/**\n * @param {!HTMLDialogElement} dialog to upgrade\n * @constructor\n */\nfunction dialogPolyfillInfo(dialog) {\n  this.dialog_ = dialog;\n  this.replacedStyleTop_ = false;\n  this.openAsModal_ = false;\n\n  // Set a11y role. Browsers that support dialog implicitly know this already.\n  if (!dialog.hasAttribute('role')) {\n    dialog.setAttribute('role', 'dialog');\n  }\n\n  dialog.show = this.show.bind(this);\n  dialog.showModal = this.showModal.bind(this);\n  dialog.close = this.close.bind(this);\n\n  dialog.addEventListener('submit', maybeHandleSubmit, false);\n\n  if (!('returnValue' in dialog)) {\n    dialog.returnValue = '';\n  }\n\n  if ('MutationObserver' in window) {\n    var mo = new MutationObserver(this.maybeHideModal.bind(this));\n    mo.observe(dialog, {attributes: true, attributeFilter: ['open']});\n  } else {\n    // IE10 and below support. Note that DOMNodeRemoved etc fire _before_ removal. They also\n    // seem to fire even if the element was removed as part of a parent removal. Use the removed\n    // events to force downgrade (useful if removed/immediately added).\n    var removed = false;\n    var cb = function() {\n      removed ? this.downgradeModal() : this.maybeHideModal();\n      removed = false;\n    }.bind(this);\n    var timeout;\n    var delayModel = function(ev) {\n      if (ev.target !== dialog) { return; }  // not for a child element\n      var cand = 'DOMNodeRemoved';\n      removed |= (ev.type.substr(0, cand.length) === cand);\n      window.clearTimeout(timeout);\n      timeout = window.setTimeout(cb, 0);\n    };\n    ['DOMAttrModified', 'DOMNodeRemoved', 'DOMNodeRemovedFromDocument'].forEach(function(name) {\n      dialog.addEventListener(name, delayModel);\n    });\n  }\n  // Note that the DOM is observed inside DialogManager while any dialog\n  // is being displayed as a modal, to catch modal removal from the DOM.\n\n  Object.defineProperty(dialog, 'open', {\n    set: this.setOpen.bind(this),\n    get: dialog.hasAttribute.bind(dialog, 'open')\n  });\n\n  this.backdrop_ = document.createElement('div');\n  this.backdrop_.className = 'backdrop';\n  this.backdrop_.addEventListener('mouseup'  , this.backdropMouseEvent_.bind(this));\n  this.backdrop_.addEventListener('mousedown', this.backdropMouseEvent_.bind(this));\n  this.backdrop_.addEventListener('click'    , this.backdropMouseEvent_.bind(this));\n}\n\ndialogPolyfillInfo.prototype = /** @type {HTMLDialogElement.prototype} */ ({\n\n  get dialog() {\n    return this.dialog_;\n  },\n\n  /**\n   * Maybe remove this dialog from the modal top layer. This is called when\n   * a modal dialog may no longer be tenable, e.g., when the dialog is no\n   * longer open or is no longer part of the DOM.\n   */\n  maybeHideModal: function() {\n    if (this.dialog_.hasAttribute('open') && isConnected(this.dialog_)) { return; }\n    this.downgradeModal();\n  },\n\n  /**\n   * Remove this dialog from the modal top layer, leaving it as a non-modal.\n   */\n  downgradeModal: function() {\n    if (!this.openAsModal_) { return; }\n    this.openAsModal_ = false;\n    this.dialog_.style.zIndex = '';\n\n    // This won't match the native <dialog> exactly because if the user set top on a centered\n    // polyfill dialog, that top gets thrown away when the dialog is closed. Not sure it's\n    // possible to polyfill this perfectly.\n    if (this.replacedStyleTop_) {\n      this.dialog_.style.top = '';\n      this.replacedStyleTop_ = false;\n    }\n\n    // Clear the backdrop and remove from the manager.\n    this.backdrop_.parentNode && this.backdrop_.parentNode.removeChild(this.backdrop_);\n    dialogPolyfill.dm.removeDialog(this);\n  },\n\n  /**\n   * @param {boolean} value whether to open or close this dialog\n   */\n  setOpen: function(value) {\n    if (value) {\n      this.dialog_.hasAttribute('open') || this.dialog_.setAttribute('open', '');\n    } else {\n      this.dialog_.removeAttribute('open');\n      this.maybeHideModal();  // nb. redundant with MutationObserver\n    }\n  },\n\n  /**\n   * Handles mouse events ('mouseup', 'mousedown', 'click') on the fake .backdrop element, redirecting them as if\n   * they were on the dialog itself.\n   *\n   * @param {!Event} e to redirect\n   */\n  backdropMouseEvent_: function(e) {\n    if (!this.dialog_.hasAttribute('tabindex')) {\n      // Clicking on the backdrop should move the implicit cursor, even if dialog cannot be\n      // focused. Create a fake thing to focus on. If the backdrop was _before_ the dialog, this\n      // would not be needed - clicks would move the implicit cursor there.\n      var fake = document.createElement('div');\n      this.dialog_.insertBefore(fake, this.dialog_.firstChild);\n      fake.tabIndex = -1;\n      fake.focus();\n      this.dialog_.removeChild(fake);\n    } else {\n      this.dialog_.focus();\n    }\n\n    var redirectedEvent = document.createEvent('MouseEvents');\n    redirectedEvent.initMouseEvent(e.type, e.bubbles, e.cancelable, window,\n        e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey,\n        e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget);\n    this.dialog_.dispatchEvent(redirectedEvent);\n    e.stopPropagation();\n  },\n\n  /**\n   * Focuses on the first focusable element within the dialog. This will always blur the current\n   * focus, even if nothing within the dialog is found.\n   */\n  focus_: function() {\n    // Find element with `autofocus` attribute, or fall back to the first form/tabindex control.\n    var target = this.dialog_.querySelector('[autofocus]:not([disabled])');\n    if (!target && this.dialog_.tabIndex >= 0) {\n      target = this.dialog_;\n    }\n    if (!target) {\n      target = findFocusableElementWithin(this.dialog_);\n    }\n    safeBlur(document.activeElement);\n    target && target.focus();\n  },\n\n  /**\n   * Sets the zIndex for the backdrop and dialog.\n   *\n   * @param {number} dialogZ\n   * @param {number} backdropZ\n   */\n  updateZIndex: function(dialogZ, backdropZ) {\n    if (dialogZ < backdropZ) {\n      throw new Error('dialogZ should never be < backdropZ');\n    }\n    this.dialog_.style.zIndex = dialogZ;\n    this.backdrop_.style.zIndex = backdropZ;\n  },\n\n  /**\n   * Shows the dialog. If the dialog is already open, this does nothing.\n   */\n  show: function() {\n    if (!this.dialog_.open) {\n      this.setOpen(true);\n      this.focus_();\n    }\n  },\n\n  /**\n   * Show this dialog modally.\n   */\n  showModal: function() {\n    if (this.dialog_.hasAttribute('open')) {\n      throw new Error('Failed to execute \\'showModal\\' on dialog: The element is already open, and therefore cannot be opened modally.');\n    }\n    if (!isConnected(this.dialog_)) {\n      throw new Error('Failed to execute \\'showModal\\' on dialog: The element is not in a Document.');\n    }\n    if (!dialogPolyfill.dm.pushDialog(this)) {\n      throw new Error('Failed to execute \\'showModal\\' on dialog: There are too many open modal dialogs.');\n    }\n\n    if (createsStackingContext(this.dialog_.parentElement)) {\n      console.warn('A dialog is being shown inside a stacking context. ' +\n          'This may cause it to be unusable. For more information, see this link: ' +\n          'https://github.com/GoogleChrome/dialog-polyfill/#stacking-context');\n    }\n\n    this.setOpen(true);\n    this.openAsModal_ = true;\n\n    // Optionally center vertically, relative to the current viewport.\n    if (dialogPolyfill.needsCentering(this.dialog_)) {\n      dialogPolyfill.reposition(this.dialog_);\n      this.replacedStyleTop_ = true;\n    } else {\n      this.replacedStyleTop_ = false;\n    }\n\n    // Insert backdrop.\n    this.dialog_.parentNode.insertBefore(this.backdrop_, this.dialog_.nextSibling);\n\n    // Focus on whatever inside the dialog.\n    this.focus_();\n  },\n\n  /**\n   * Closes this HTMLDialogElement. This is optional vs clearing the open\n   * attribute, however this fires a 'close' event.\n   *\n   * @param {string=} opt_returnValue to use as the returnValue\n   */\n  close: function(opt_returnValue) {\n    if (!this.dialog_.hasAttribute('open')) {\n      throw new Error('Failed to execute \\'close\\' on dialog: The element does not have an \\'open\\' attribute, and therefore cannot be closed.');\n    }\n    this.setOpen(false);\n\n    // Leave returnValue untouched in case it was set directly on the element\n    if (opt_returnValue !== undefined) {\n      this.dialog_.returnValue = opt_returnValue;\n    }\n\n    // Triggering \"close\" event for any attached listeners on the <dialog>.\n    var closeEvent = new supportCustomEvent('close', {\n      bubbles: false,\n      cancelable: false\n    });\n    safeDispatchEvent(this.dialog_, closeEvent);\n  }\n\n});\n\nvar dialogPolyfill = {};\n\ndialogPolyfill.reposition = function(element) {\n  var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  var topValue = scrollTop + (window.innerHeight - element.offsetHeight) / 2;\n  element.style.top = Math.max(scrollTop, topValue) + 'px';\n};\n\ndialogPolyfill.isInlinePositionSetByStylesheet = function(element) {\n  for (var i = 0; i < document.styleSheets.length; ++i) {\n    var styleSheet = document.styleSheets[i];\n    var cssRules = null;\n    // Some browsers throw on cssRules.\n    try {\n      cssRules = styleSheet.cssRules;\n    } catch (e) {}\n    if (!cssRules) { continue; }\n    for (var j = 0; j < cssRules.length; ++j) {\n      var rule = cssRules[j];\n      var selectedNodes = null;\n      // Ignore errors on invalid selector texts.\n      try {\n        selectedNodes = document.querySelectorAll(rule.selectorText);\n      } catch(e) {}\n      if (!selectedNodes || !inNodeList(selectedNodes, element)) {\n        continue;\n      }\n      var cssTop = rule.style.getPropertyValue('top');\n      var cssBottom = rule.style.getPropertyValue('bottom');\n      if ((cssTop && cssTop !== 'auto') || (cssBottom && cssBottom !== 'auto')) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\ndialogPolyfill.needsCentering = function(dialog) {\n  var computedStyle = window.getComputedStyle(dialog);\n  if (computedStyle.position !== 'absolute') {\n    return false;\n  }\n\n  // We must determine whether the top/bottom specified value is non-auto.  In\n  // WebKit/Blink, checking computedStyle.top == 'auto' is sufficient, but\n  // Firefox returns the used value. So we do this crazy thing instead: check\n  // the inline style and then go through CSS rules.\n  if ((dialog.style.top !== 'auto' && dialog.style.top !== '') ||\n      (dialog.style.bottom !== 'auto' && dialog.style.bottom !== '')) {\n    return false;\n  }\n  return !dialogPolyfill.isInlinePositionSetByStylesheet(dialog);\n};\n\n/**\n * @param {!Element} element to force upgrade\n */\ndialogPolyfill.forceRegisterDialog = function(element) {\n  if (window.HTMLDialogElement || element.showModal) {\n    console.warn('This browser already supports <dialog>, the polyfill ' +\n        'may not work correctly', element);\n  }\n  if (element.localName !== 'dialog') {\n    throw new Error('Failed to register dialog: The element is not a dialog.');\n  }\n  new dialogPolyfillInfo(/** @type {!HTMLDialogElement} */ (element));\n};\n\n/**\n * @param {!Element} element to upgrade, if necessary\n */\ndialogPolyfill.registerDialog = function(element) {\n  if (!element.showModal) {\n    dialogPolyfill.forceRegisterDialog(element);\n  }\n};\n\n/**\n * @constructor\n */\ndialogPolyfill.DialogManager = function() {\n  /** @type {!Array<!dialogPolyfillInfo>} */\n  this.pendingDialogStack = [];\n\n  var checkDOM = this.checkDOM_.bind(this);\n\n  // The overlay is used to simulate how a modal dialog blocks the document.\n  // The blocking dialog is positioned on top of the overlay, and the rest of\n  // the dialogs on the pending dialog stack are positioned below it. In the\n  // actual implementation, the modal dialog stacking is controlled by the\n  // top layer, where z-index has no effect.\n  this.overlay = document.createElement('div');\n  this.overlay.className = '_dialog_overlay';\n  this.overlay.addEventListener('click', function(e) {\n    this.forwardTab_ = undefined;\n    e.stopPropagation();\n    checkDOM([]);  // sanity-check DOM\n  }.bind(this));\n\n  this.handleKey_ = this.handleKey_.bind(this);\n  this.handleFocus_ = this.handleFocus_.bind(this);\n\n  this.zIndexLow_ = 100000;\n  this.zIndexHigh_ = 100000 + 150;\n\n  this.forwardTab_ = undefined;\n\n  if ('MutationObserver' in window) {\n    this.mo_ = new MutationObserver(function(records) {\n      var removed = [];\n      records.forEach(function(rec) {\n        for (var i = 0, c; c = rec.removedNodes[i]; ++i) {\n          if (!(c instanceof Element)) {\n            continue;\n          } else if (c.localName === 'dialog') {\n            removed.push(c);\n          }\n          removed = removed.concat(c.querySelectorAll('dialog'));\n        }\n      });\n      removed.length && checkDOM(removed);\n    });\n  }\n};\n\n/**\n * Called on the first modal dialog being shown. Adds the overlay and related\n * handlers.\n */\ndialogPolyfill.DialogManager.prototype.blockDocument = function() {\n  document.documentElement.addEventListener('focus', this.handleFocus_, true);\n  document.addEventListener('keydown', this.handleKey_);\n  this.mo_ && this.mo_.observe(document, {childList: true, subtree: true});\n};\n\n/**\n * Called on the first modal dialog being removed, i.e., when no more modal\n * dialogs are visible.\n */\ndialogPolyfill.DialogManager.prototype.unblockDocument = function() {\n  document.documentElement.removeEventListener('focus', this.handleFocus_, true);\n  document.removeEventListener('keydown', this.handleKey_);\n  this.mo_ && this.mo_.disconnect();\n};\n\n/**\n * Updates the stacking of all known dialogs.\n */\ndialogPolyfill.DialogManager.prototype.updateStacking = function() {\n  var zIndex = this.zIndexHigh_;\n\n  for (var i = 0, dpi; dpi = this.pendingDialogStack[i]; ++i) {\n    dpi.updateZIndex(--zIndex, --zIndex);\n    if (i === 0) {\n      this.overlay.style.zIndex = --zIndex;\n    }\n  }\n\n  // Make the overlay a sibling of the dialog itself.\n  var last = this.pendingDialogStack[0];\n  if (last) {\n    var p = last.dialog.parentNode || document.body;\n    p.appendChild(this.overlay);\n  } else if (this.overlay.parentNode) {\n    this.overlay.parentNode.removeChild(this.overlay);\n  }\n};\n\n/**\n * @param {Element} candidate to check if contained or is the top-most modal dialog\n * @return {boolean} whether candidate is contained in top dialog\n */\ndialogPolyfill.DialogManager.prototype.containedByTopDialog_ = function(candidate) {\n  while (candidate = findNearestDialog(candidate)) {\n    for (var i = 0, dpi; dpi = this.pendingDialogStack[i]; ++i) {\n      if (dpi.dialog === candidate) {\n        return i === 0;  // only valid if top-most\n      }\n    }\n    candidate = candidate.parentElement;\n  }\n  return false;\n};\n\ndialogPolyfill.DialogManager.prototype.handleFocus_ = function(event) {\n  var target = event.composedPath ? event.composedPath()[0] : event.target;\n\n  if (this.containedByTopDialog_(target)) { return; }\n\n  if (document.activeElement === document.documentElement) { return; }\n\n  event.preventDefault();\n  event.stopPropagation();\n  safeBlur(/** @type {Element} */ (target));\n\n  if (this.forwardTab_ === undefined) { return; }  // move focus only from a tab key\n\n  var dpi = this.pendingDialogStack[0];\n  var dialog = dpi.dialog;\n  var position = dialog.compareDocumentPosition(target);\n  if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n    if (this.forwardTab_) {\n      // forward\n      dpi.focus_();\n    } else if (target !== document.documentElement) {\n      // backwards if we're not already focused on <html>\n      document.documentElement.focus();\n    }\n  }\n\n  return false;\n};\n\ndialogPolyfill.DialogManager.prototype.handleKey_ = function(event) {\n  this.forwardTab_ = undefined;\n  if (event.keyCode === 27) {\n    event.preventDefault();\n    event.stopPropagation();\n    var cancelEvent = new supportCustomEvent('cancel', {\n      bubbles: false,\n      cancelable: true\n    });\n    var dpi = this.pendingDialogStack[0];\n    if (dpi && safeDispatchEvent(dpi.dialog, cancelEvent)) {\n      dpi.dialog.close();\n    }\n  } else if (event.keyCode === 9) {\n    this.forwardTab_ = !event.shiftKey;\n  }\n};\n\n/**\n * Finds and downgrades any known modal dialogs that are no longer displayed. Dialogs that are\n * removed and immediately readded don't stay modal, they become normal.\n *\n * @param {!Array<!HTMLDialogElement>} removed that have definitely been removed\n */\ndialogPolyfill.DialogManager.prototype.checkDOM_ = function(removed) {\n  // This operates on a clone because it may cause it to change. Each change also calls\n  // updateStacking, which only actually needs to happen once. But who removes many modal dialogs\n  // at a time?!\n  var clone = this.pendingDialogStack.slice();\n  clone.forEach(function(dpi) {\n    if (removed.indexOf(dpi.dialog) !== -1) {\n      dpi.downgradeModal();\n    } else {\n      dpi.maybeHideModal();\n    }\n  });\n};\n\n/**\n * @param {!dialogPolyfillInfo} dpi\n * @return {boolean} whether the dialog was allowed\n */\ndialogPolyfill.DialogManager.prototype.pushDialog = function(dpi) {\n  var allowed = (this.zIndexHigh_ - this.zIndexLow_) / 2 - 1;\n  if (this.pendingDialogStack.length >= allowed) {\n    return false;\n  }\n  if (this.pendingDialogStack.unshift(dpi) === 1) {\n    this.blockDocument();\n  }\n  this.updateStacking();\n  return true;\n};\n\n/**\n * @param {!dialogPolyfillInfo} dpi\n */\ndialogPolyfill.DialogManager.prototype.removeDialog = function(dpi) {\n  var index = this.pendingDialogStack.indexOf(dpi);\n  if (index === -1) { return; }\n\n  this.pendingDialogStack.splice(index, 1);\n  if (this.pendingDialogStack.length === 0) {\n    this.unblockDocument();\n  }\n  this.updateStacking();\n};\n\ndialogPolyfill.dm = new dialogPolyfill.DialogManager();\ndialogPolyfill.formSubmitter = null;\ndialogPolyfill.imagemapUseValue = null;\n\n/**\n * Installs global handlers, such as click listers and native method overrides. These are needed\n * even if a no dialog is registered, as they deal with <form method=\"dialog\">.\n */\nif (window.HTMLDialogElement === undefined) {\n\n  /**\n   * If HTMLFormElement translates method=\"DIALOG\" into 'get', then replace the descriptor with\n   * one that returns the correct value.\n   */\n  var testForm = document.createElement('form');\n  testForm.setAttribute('method', 'dialog');\n  if (testForm.method !== 'dialog') {\n    var methodDescriptor = Object.getOwnPropertyDescriptor(HTMLFormElement.prototype, 'method');\n    if (methodDescriptor) {\n      // nb. Some older iOS and older PhantomJS fail to return the descriptor. Don't do anything\n      // and don't bother to update the element.\n      var realGet = methodDescriptor.get;\n      methodDescriptor.get = function() {\n        if (isFormMethodDialog(this)) {\n          return 'dialog';\n        }\n        return realGet.call(this);\n      };\n      var realSet = methodDescriptor.set;\n      /** @this {HTMLElement} */\n      methodDescriptor.set = function(v) {\n        if (typeof v === 'string' && v.toLowerCase() === 'dialog') {\n          return this.setAttribute('method', v);\n        }\n        return realSet.call(this, v);\n      };\n      Object.defineProperty(HTMLFormElement.prototype, 'method', methodDescriptor);\n    }\n  }\n\n  /**\n   * Global 'click' handler, to capture the <input type=\"submit\"> or <button> element which has\n   * submitted a <form method=\"dialog\">. Needed as Safari and others don't report this inside\n   * document.activeElement.\n   */\n  document.addEventListener('click', function(ev) {\n    dialogPolyfill.formSubmitter = null;\n    dialogPolyfill.imagemapUseValue = null;\n    if (ev.defaultPrevented) { return; }  // e.g. a submit which prevents default submission\n\n    var target = /** @type {Element} */ (ev.target);\n    if ('composedPath' in ev) {\n      var path = ev.composedPath();\n      target = path.shift() || target;\n    }\n    if (!target || !isFormMethodDialog(target.form)) { return; }\n\n    var valid = (target.type === 'submit' && ['button', 'input'].indexOf(target.localName) > -1);\n    if (!valid) {\n      if (!(target.localName === 'input' && target.type === 'image')) { return; }\n      // this is a <input type=\"image\">, which can submit forms\n      dialogPolyfill.imagemapUseValue = ev.offsetX + ',' + ev.offsetY;\n    }\n\n    var dialog = findNearestDialog(target);\n    if (!dialog) { return; }\n\n    dialogPolyfill.formSubmitter = target;\n\n  }, false);\n\n  /**\n   * Global 'submit' handler. This handles submits of `method=\"dialog\"` which are invalid, i.e.,\n   * outside a dialog. They get prevented.\n   */\n  document.addEventListener('submit', function(ev) {\n    var form = ev.target;\n    var dialog = findNearestDialog(form);\n    if (dialog) {\n      return;  // ignore, handle there\n    }\n\n    var submitter = findFormSubmitter(ev);\n    var formmethod = submitter && submitter.getAttribute('formmethod') || form.getAttribute('method');\n    if (formmethod === 'dialog') {\n      ev.preventDefault();\n    }\n  });\n\n  /**\n   * Replace the native HTMLFormElement.submit() method, as it won't fire the\n   * submit event and give us a chance to respond.\n   */\n  var nativeFormSubmit = HTMLFormElement.prototype.submit;\n  var replacementFormSubmit = function () {\n    if (!isFormMethodDialog(this)) {\n      return nativeFormSubmit.call(this);\n    }\n    var dialog = findNearestDialog(this);\n    dialog && dialog.close();\n  };\n  HTMLFormElement.prototype.submit = replacementFormSubmit;\n}\n\nexport default dialogPolyfill;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}